package main

import (
    "fmt"
	"log"
	"strings"

	"github.com/charmbracelet/bubbles/table"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

const (
	primaryColor    = "240"
	focusColor      = "69"
	maxWidth        = 75
	maxHeight       = 15
	buttonWidth     = 15
	buttonHeight    = 1
	borderChar      = "-"
    headerBar       = "-"
    headerText      = "tinyC2"
)

var (
	headerStyle = func() lipgloss.Style {
		b := lipgloss.RoundedBorder()
		b.Right = headerBar
        b.Left = headerBar
		return lipgloss.NewStyle().BorderStyle(b).Padding(0, 1)
	}()

	bigBoxStyle = lipgloss.NewStyle().
        Width(maxWidth).
        Height(maxHeight).
        Align(lipgloss.Center, lipgloss.Center).
        BorderForeground(lipgloss.Color(primaryColor))

	focusTextBoxStyle = lipgloss.NewStyle().
        Width(buttonWidth).
        Height(buttonHeight).
        Align(lipgloss.Center, lipgloss.Center).
        BorderStyle(lipgloss.NormalBorder()).
        BorderForeground(lipgloss.Color(focusColor))

    baseTableStyle = lipgloss.NewStyle().
		BorderStyle(lipgloss.NormalBorder()).
		BorderForeground(lipgloss.Color(primaryColor))

	textBoxStyle = lipgloss.NewStyle().
        Width(buttonWidth).
        Height(buttonHeight).
        Align(lipgloss.Center, lipgloss.Center).
        BorderStyle(lipgloss.HiddenBorder())
)

type sessionState uint
const (
	agentsState             sessionState = iota
	agentInfoState
	agentEditState
    cliState
	listenersState
	listenerEditState
    listenerInfoState
    listenerNewState
	mainState
)

type viewFocus uint
const (
    listenersNewFocus       viewFocus = iota
    listenersEditFocus
    listenersDeleteFocus
    listenersInfoFocus
    listenerEditNameFocus
    listenerEditIpFocus
    listenerEditPortFocus
    listenerEditSaveFocus
    listenerEditCancelFocus
	mainAgentsFocus
	mainListenersFocus
	mainCLIFocus
)

type textBoxModel struct {
	text string
}

type MainModel struct {
	state           sessionState
	focus           viewFocus
	agentsBox       textBoxModel
	listenersBox    textBoxModel
	cliBox          textBoxModel
	infoBox         textBoxModel
	bigBox          textBoxModel
    newBox          textBoxModel      
    editBox         textBoxModel
    deleteBox       textBoxModel
    listenersTable  table.Model

}

func NewModel() MainModel {
	m := MainModel{
		state:          mainState,
		focus:          mainAgentsFocus,
		agentsBox:      textBoxModel{text: "Agents"},
		bigBox:         textBoxModel{text: "TODO bigBox.text"},
		cliBox:         textBoxModel{text: "cli"},
        deleteBox:      textBoxModel{text: "Delete"},
        editBox:        textBoxModel{text: "Edit"},
        infoBox:        textBoxModel{text: "View"},
		listenersBox:   textBoxModel{text: "Listeners"},
        newBox:         textBoxModel{text: "New"},   
	}
        m.listenersTable = m.getDemoTable()
	return m
}

func (m MainModel) Init() tea.Cmd {
	return nil
}

func (m MainModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var (
		cmd tea.Cmd
		cmds []tea.Cmd
	)

	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "esc", "q":
            switch m.state {
            case mainState:
                return m, tea.Quit
            default:
                m.state = mainState
                m.focus = mainAgentsFocus
                m.listenersTable.Blur()
                m.listenersTable.SetCursor(0)
            }
			
		case "tab":
			m.focus = m.NextFocus()
        case "enter", "n":
            m.state, m.focus = m.NextState()
            if m.state == listenersState {
                m.listenersTable.Focus()
            }
		}
	}
    m.listenersTable, cmd = m.listenersTable.Update(msg)
    cmds = append(cmds, cmd)
	return m, tea.Batch(cmds...)
}

func (m MainModel) NextFocus() viewFocus {
    s := m.state
    f := m.focus
	switch s {
	case mainState:
		switch m.focus {
		case mainAgentsFocus:
			f = mainListenersFocus
		case mainListenersFocus:
			f = mainCLIFocus
		case mainCLIFocus:
			f = mainAgentsFocus
		}
    case listenersState:
        switch m.focus {
        case listenersNewFocus:
            f = listenersEditFocus
        case listenersEditFocus: 
            f = listenersInfoFocus
        case listenersInfoFocus:
            f = listenersDeleteFocus
        case listenersDeleteFocus:
            f = listenersNewFocus
        }
	}
	return f
}

func (m MainModel) NextState() (sessionState, viewFocus) {
    s := m.state
    f := m.focus
    switch f {
    case mainAgentsFocus:
        s = agentsState
    case mainListenersFocus:
        s = listenersState
        f = listenersNewFocus
    case mainCLIFocus:
        s = cliState
    case listenersNewFocus:
        s = listenerNewState
    case listenersEditFocus:
        s = listenerEditState
    case listenersDeleteFocus:
        fmt.Printf("TODO: Delete listener %s.", m.listenersTable.SelectedRow()[1])
    case listenersInfoFocus:
        s = listenerInfoState
    }
    return s, f
} 

func (m MainModel) View() string {
	switch m.state {
	case mainState:
		return m.mainView()
    case listenersState:
        return m.listenersView()
    case listenerNewState:
        return fmt.Sprintf("TODO: New listener.")
    case listenerEditState:
        return fmt.Sprintf("TODO: Edit listener %s.", m.listenersTable.SelectedRow()[1])
    case listenerInfoState:
        return fmt.Sprintf("TODO: View info of listener %s.", m.listenersTable.SelectedRow()[1])
	}
	return ""
}

func (m MainModel) mainView() string {
	var buttons string
	switch m.focus {
	case mainAgentsFocus:
		buttons = lipgloss.JoinHorizontal(lipgloss.Top, focusTextBoxStyle.Render(m.agentsBox.text),
			textBoxStyle.Render(m.listenersBox.text), textBoxStyle.Render(m.cliBox.text))
	case mainListenersFocus:
		buttons = lipgloss.JoinHorizontal(lipgloss.Top, textBoxStyle.Render(m.agentsBox.text),
			focusTextBoxStyle.Render(m.listenersBox.text), textBoxStyle.Render(m.cliBox.text))
	case mainCLIFocus:
		buttons = lipgloss.JoinHorizontal(lipgloss.Top, textBoxStyle.Render(m.agentsBox.text),
			textBoxStyle.Render(m.listenersBox.text), focusTextBoxStyle.Render(m.cliBox.text))
	}
	s := lipgloss.JoinVertical(lipgloss.Top, m.getHeader(headerText), bigBoxStyle.Render(m.bigBox.text), m.getFooter(), buttons)
	return s
}

func (m MainModel) listenersView() string {
	var buttons string
	switch m.focus {
	case listenersNewFocus:
		buttons = lipgloss.JoinHorizontal(lipgloss.Top, focusTextBoxStyle.Render(m.newBox.text),
			textBoxStyle.Render(m.editBox.text), textBoxStyle.Render(m.infoBox.text), textBoxStyle.Render(m.deleteBox.text))
	case listenersEditFocus:
		buttons = lipgloss.JoinHorizontal(lipgloss.Top, textBoxStyle.Render(m.newBox.text),
            focusTextBoxStyle.Render(m.editBox.text), textBoxStyle.Render(m.infoBox.text), textBoxStyle.Render(m.deleteBox.text))
	case listenersInfoFocus:
		buttons = lipgloss.JoinHorizontal(lipgloss.Top, textBoxStyle.Render(m.newBox.text),
			textBoxStyle.Render(m.editBox.text), focusTextBoxStyle.Render(m.infoBox.text), textBoxStyle.Render(m.deleteBox.text))
    case listenersDeleteFocus:
        buttons = lipgloss.JoinHorizontal(lipgloss.Top, textBoxStyle.Render(m.newBox.text),
            textBoxStyle.Render(m.editBox.text), textBoxStyle.Render(m.infoBox.text), focusTextBoxStyle.Render(m.deleteBox.text))
	}

	s := lipgloss.JoinVertical(lipgloss.Top, m.getHeader(headerText), baseTableStyle.Render(m.listenersTable.View()), m.getFooter(), buttons)
	return s
}

func (m MainModel) getHeader(s string) string {
    lline := strings.Repeat(borderChar, 3)
	text := headerStyle.Render(s)
	rline := strings.Repeat(borderChar, maxWidth - (len(lline) + len(headerText) + 4))
	return lipgloss.JoinHorizontal(lipgloss.Center, lline, text, rline)
}

func (m MainModel) getFooter() string {
	line := strings.Repeat(borderChar, maxWidth)
	return lipgloss.JoinHorizontal(lipgloss.Center, line)
}

func main() {
	p := tea.NewProgram(NewModel())
	if _, err := p.Run(); err != nil {
		log.Println(err)
	}
}

func (m MainModel) getDemoTable() table.Model {
    numCol := 5
    tWidth := (maxWidth / numCol) - ((2 * numCol) / numCol)
    tHeight := maxHeight - 4

	columns := []table.Column{
		{Title: "Id",       Width: tWidth},
		{Title: "Name",     Width: tWidth},
		{Title: "Ip",       Width: tWidth},
		{Title: "Port",     Width: tWidth},
		{Title: "Status",   Width: tWidth},
	}

	rows := []table.Row{
		{"1", "Tokyo",      "127.0.0.1",    "80", "1"},
		{"2", "Delhi",      "127.0.0.2",    "81", "1"},
		{"3", "Shanghai",   "127.0.0.3",    "82", "1"},
		{"4", "Dhaka",      "127.0.0.4",    "84", "1"},
		{"5", "Sao",        "127.0.0.5",    "85", "1"},
		{"6", "Colombo",    "127.0.0.6",    "86", "1"},
		{"7", "Cairo",      "127.0.0.7",    "87", "1"},
		{"8", "Beijing",    "127.0.0.8",    "88", "1"},
		{"9", "Mumbai",     "127.0.0.9",    "89", "1"},
		{"10", "Osaka",     "127.0.0.10",   "90", "1"},
	}

	t := table.New(
		table.WithColumns(columns),
		table.WithRows(rows),
		table.WithFocused(false),
		table.WithHeight(tHeight),
	)

	s := table.DefaultStyles()
	s.Header = s.Header.
		BorderStyle(lipgloss.NormalBorder()).
		BorderForeground(lipgloss.Color(primaryColor)).
		BorderBottom(true).
		Bold(false)
	s.Selected = s.Selected.
		Foreground(lipgloss.Color(primaryColor)).
		Background(lipgloss.Color(focusColor)).
		Bold(false).
        BorderStyle(lipgloss.NormalBorder())
	t.SetStyles(s)

	return t
}
